## What I learned today

It seems to be quite hard to split the different domains cleanly. After feeling the urge to separate the different domains into own directory tree,it became appearent that some topics lead to implicit coupling via imports and dependencies. Given the ORM setup, splitting up the domain specific ORM definitions and putting them in the different branches would lead to circular dependencies or only forward dependencies, coupling together the different ORM models.

Same with the services. I found, that the expense authorization service brings together User and Expense domain to much. As suggested by Claude 4.5, decoupling would allow to follow the DDD principles more closely. These leave me in a state of confusion. Given my monolithic approach (for now), I would like to minimize the couple even further and not import one service definition of one domain just in into the other. The question is: How should domain services performing tasks in bounded contexts interact with each other? How should interfaces be defined here?

The suggested solution is some kind of so-called policy pattern. Defining the the expected policy in expense service while implementing it in the User domain. This would solve the issue of cross domain dependencies as both only need to be imported on root / app composition level (leaving aside the import of the policy in the domain for type checking during implementation).
This is not decoupled enough for my taste. Services should be completely separated (?) and performing tasks for one another.

This brought be to the fundamental questions of the domains itself. Is authorizing an expense part of the expense domain.

Personally, I would like to decouple it a little more and prepare the user domain to become a full fetched IAM as my goal is to also implement some kind of report generation tool for period based expense reports, transparency reports as well as integrating a domain about attachment handling with ORC and so on...

For the time being, I am going to decouple the domains an implement an Expense Auth Policy as a contract template and Anti Corruption Layer. The policiy implementation will be done in the user domain (future iam domain), as Policy (basically the same as putting the auth service just in the user domain). I am sure this will help to later segregate the different domains in separate micro services.


Idea with the help of Claude:
src/
├── iam/  # ← Identity & Access Management context
│   ├── domain/
│   │   ├── model.py              # User, Role, Permission
│   │   ├── policies.py           # Authorization policies
│   │   ├── repository.py         # IUserRepository
│   │   └── events.py             # User-related domain events
│   ├── application/
│   │   ├── user_service.py       # User CRUD operations
│   │   └── authorization_service.py  # Authorization decisions
│   └── infrastructure/
│       ├── orm.py                # UserORM
│       └── repository.py         # SqlAlchemyUserRepository
│
├── expense_management/
│   ├── domain/
│   │   ├── model.py              # Expense aggregate
│   │   ├── repository.py
│   │   └── policies.py           # ← Define what you need from IAM
│   ├── application/
│   │   └── services.py
│   └── infrastructure/
│       └── ...
│
├── reporting/  # ← Future domain
│   └── ...
│
├── attachments/  # ← Future domain with OCR
│   └── ...
│
└── shared/
    ├── domain/
    │   └── events.py             # Event infrastructure
    └── infrastructure/
        └── event_bus.py          # In-process event bus (for now)


